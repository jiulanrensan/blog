[参考文章](https://juejin.cn/post/6844903453836181517)
## 1. 实例化RegExp对象
### 1.1 字面量方式
`const reg =/\bis\b/g`
### 1.2 构造函数
`const reg = new RegExp('\\bis\\b', 'g')`

## 2. 正则表达式语法
### 2.1 修饰符
* g：global 全局匹配
* i：ignore case 不区分大小写的匹配
* m：multiple lines 多行匹配

### 2.2 原义字符
`/is/`就匹配is字符，就是字符原本的意思

### 2.3 元字符
`* + ? $ ^ . | \ ( ) { } [ ]`

### 2.4 非打印字符
> 这里只列出常用的，遇到时再补充
| 字符 | 描述 |
| -- | -- |
| `\n` | 匹配换行符 |
| `\r` | 匹配回车符 |
| `\s` | 匹配任何空白字符，包括空格、制表符、换页符等等 |
| `\S` | 匹配任何非空白字符 |


### 2.5 字符类[]
其实就是[]里面的所有字符取其本身的意思
```
[1] // 匹配1
[123] // 匹配123任意一个数字
[1-9] // 匹配1-9任意一个数字
```
### 2.6 字符类取反
即与2.5相反

### 2.7 [-]范围
同2.5的例子
```
[1-9] // 匹配1-9任意一个数字
// 常用
[a-z]
[A-Z]
[0-9]
[a-z0-9A-Z]
```

### 2.8 预定义类
| 字符 | 描述 |
| -- | -- |
| `.` | 除了回车符和换行符之外的所有字符 |
| `\d` | 数字字符 |
| `\D` | 非数字字符 |
| `\s` | 空白符 |
| `\S` | 非空白符 |
| `\w` | 字母、数字、下划线 |
| `\W` | 除开字母、数字、下划线 |

### 2.9 边界
| 字符 | 描述 |
| -- | -- |
| `^` | 以xx开头 |
| `$` | 以xx结尾 |
| `\b` | 单词边界，指[a-zA-Z_0-9]之外的字符 |
| `\B` | 非单词边界 |
```js
var r1= /\bdog/g
var r2= /\Bdog/g

'@dog@dogdog@'.replace(r1, 'a') // ouput: @a@adog@
'@dog@dogdog@'.replace(r2, 'a') // output: @dog@doga@
```

### 2.10 量词
| 字符 | 描述 |
| -- | -- |
| `?` | 出现零次或一次 |
| `*` | 出现零次或多次(任意次) |
| `+` | 出现一次或多次（至少一次） |
| `{n}` | 对应零次或者n次 |
| `{n,m}` | 至少出现n次但不超过m次 |
| `{n,}` | 出现n次及n次以上 |
| `{0,n}` | 对应零次或者n次 |

### 2.11 贪婪与懒惰（非贪婪）
正则表达式默认会匹配贪婪模式，就是可能多的匹配
```js
var reg = /\d{3,6}/
'1234567890'.replace(reg, '')
// output 7890
```
```js
// 在量词后面加?开启懒惰模式
var reg = /\d{3,6}?/
'1234567890'.replace(reg, '')
// output 4567890
```
### 2.12 分组与反向引用
结合https://regexper.com/查看分组
* 不分组 `/abc{2}`
* 分组 `/(abc){2}/`(abc)会有个编号group #1，这里有两个group1

当一个正则表达式被分组之后，每个分组自动被赋予一个组号，分别是$1,$2...

反向引用
```js
var reg = /^(\d{4})[/-](\d{2})[/-](\d{2})$/
'2016/11/11'.replace(reg, '$1年$2月$3日') // output 2016年11月11日 就是把 $1 替换成 $1年
```
```js
var reg = /([1-9])([a-z]+)/g
'123g34325sg4343'.replace(reg, '$1+$2-')
// output "123+g-34325+sg-4343"
// 12($1)($2)3432($1)($2)4343
```

### 2.13 非元捕获字符
正则中的正向指的是从文本头部指向尾部方向，反向相反
1. `?:`  
2. 正向预查
`?=` 正向肯定预查/先行断言
`?!` 正向否定预查
3. 反向预查
`?<=` 反向肯定预查/后行断言
`?<!` 反向否定预查

可以使用上面的非元捕获字符来重写捕获，忽略相关匹配

* `?:` 匹配但不获取匹配结果
```js
var reg = /^(?:\d{4})[/-](\d{2})[/-](\d{2})$/
'2016/11/11'.replace(reg, '$1年$2月') // output 11年11月 没有获取2016
```
> 例如， 'industr(?:y|ies)' 就是一个比 'industry|industries' 更简略的表达式

* `?=` 
举了例子：`x(?=y)` 匹配'x'仅仅当'x'后面跟着'y'
```js
'Windows2000'.match(/Windows(?=95|98|NT|2000)/) // ['Windows', ...]
'Windows3.1'.match(/Windows(?=95|98|NT|2000)/) // null
'Windows2000'.match(/Windows(95|98|NT|2000)/) // ['Windows2000', '2000', ...]
```

* `?!` 
`x(?!y)` 仅仅当'x'后面不跟着'y'时匹配'x'
```js
// 疑问？
// 数字后面跟着小数点的不匹配，所以3.不匹配，只匹配141
'3.141'.match(/\d+(?!\.)/) // ['141', ...]
// 数字小数点 后面跟着141不匹配，所以null
"3.141".match(/\d\.(?!141)/) // null
// 同上，所以匹配3.
"3.121".match(/\d\.(?!141)/) // ['3.', ...]


'Windows2000'.match(/Windows(?!95|98|NT|2000)/) // null
'Windows3.1'.match(/Windows(?!95|98|NT|2000)/) // ['Windows', ...]
```

* `?<=`
`(?<=y)x` 匹配'x'仅当'x'前面是'y'
```js
'JackSprat'.match(/(?<=Jack)Sprat/) // ['Sprat', ...]
```

* `?<!`
`(?<!y)x` 仅仅当'x'前面不是'y'时匹配'x'
```js
// 仅仅当这个数字前面没有负号的时候才会匹配
/(?<!-)\d+/.exec('3') // ['3', ...]
/(?<!-)\d+/.exec('-3') // null
```

### 2.14 运算符优先级
从上到下，从左到右
| 字符 |
| -- |
| `\` |
| `(), (?:), (?=), []` |
| `*, +, ?, {n}, {n,}, {n,m}` |
| `^, $, \任何元字符、任何字符` |


## 3. 记录正则表达式
### 3.1 货币格式化
```js
'123456789'.replace(/(\d)(?=(?:\d{3})+$)/g, '$1,')
```