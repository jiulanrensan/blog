## 指针
指针变量是一种特殊的变量，它存放的不是数据，而是另一种变量的地址

### 示例
```
#include<stdio.h>

int main(){
    int a = 100,b=10;
    // 定义指针变量
    // *表示定义的为指针变量
    int *point_1, *point_2;
    // 把变量a的地址赋值给point_1,注意&,表示取指针地址
    point_1 = &a;
    point_2 = &b;

    // 输出ab的值
    printf("a=%d,b=%d\n",a,b);
    // 输出指针，即a,b在内存中的地址,注意%p
    printf("%p,%p\n", point_1,point_2);
    // 输出变量a,b,*point_1就表示指针指向的变量
    printf("*p_1=%d,*p_2=%d\n", *point_1, *point_2);
    return 0;
}
```
如果有以下赋值语句：
```
*p = 1;
```
表示将整数 1 赋给 p 当前所指向的变量，如果 p 指向变量 a，则相当于把 1 赋给 a，即 a=1;


> 程序中 p=p1;p1=p2;p2=p; 两个变量的值交换要利用第三个变量

> 实际上学到指针我们可以用更加简洁的方法: `p1=&b,p2=&a`


### 指针变量作为函数参数
函数的参数不仅可以是整形，浮点型等数据，也可以是指针类型。他的作用是将一个变量的地址传送到另一个函数中
```
#include<stdio.h>
int main() {
    void swap(int *p_1, int *p_2);
    int *p1, *p2, a, b;
    printf("enter:");
    scanf("%d,%d",&a,&b);
    p1 = &a;
    p2 = &b;
    if (a<b){
        swap(p1, p2);
    }
    printf("max=%d,min=%d\n", a,b);
    return 0;
}
void swap(int *p_1, int *p_2){
    int temp;
    // 注意：这里是交换指针所指变量的值
    // 即指针的指向没有发生改变
    // 但是变量 a 和 b 的值改变了
    temp = *p_1;
    *p_1 = *p_2;
    *p_2 = temp;
}
```
swap 函数的两个形参 point_1 和 point_2 是指针变量。程序运行时，先执行 main 函数，输入 a 和 b 的值（我们输入的是 23 和 34），然后将 a 和 b 的地址分别赋给 int 指针变量 p1 和 p2，使 p1 指向 a，p2 指向 b

注意实参 p1 和 p2 是指针变量，在函数调用时，将实参变量的值传送给形参变量，采取的依然是“值传递”方式

函数调用结束后，形参 point_1 和 point_2 不复存在（已释放）

如果参数不为指针变量？
```
// 如以下例子
void swap(int x ,int y){
    int temp;
    temp = x;
    x = y;
    y = temp;
}
```
在函数调用时，a 的值传送给 x，b 的值传送给 y，执行完 swap 函数后，x 和 y 的值是互换了，但并未影响到 a 和 b 的值。在函数结束时，变量 x 和 y 释放了，main 函数中的 a 和 b 并未互换。也就是说，这种单向的值传递，形参值的改变不能使实参的值随之改变

为了使在函数中改变了的变量值能被主调函数 main 所用，不能采取上述的把要改变的变量作为参数的办法，而应该用指针变量作为函数参数，在函数执行过程中使指针变量所指向的变量值发生变化，函数调用结束后，这些变量值依然保留了下来

```
#include<stdio.h>
int main(){
    void exchange(int * q1,int * q2,int * q3);
    int a,b,c,*p1,*p2,*p3;

    printf("please enter 3 integer number:");
    scanf("%d%d%d",&a,&b,&c);
    p1 = &a;
    p2 = &b;
    p3 = &c;
    exchange(p1,p2,p3);

    printf("the order is :%d,%d,%d\n",a,b,c);

    return 0;
}

void exchange(int *q1,int *q2,int *q3){
    void swap(int *p1,int *p2);
    if(* q1<* q2) swap(q1,q2);
    if(* q1<* q3) swap(q1,q3);
    if(* q2<* q3) swap(q2,q3);
}

void swap(int *p1,int *p2){
    int temp;

    temp = *p1;
    *p1 = *p2;
    *p2 = temp;
}
```

### 通过指针引用数组

```
int a[10]={1,2,3,4,5,6,7,8,9,10};
int *p;
p = &a[0];
```
以上是使指针变量 p 指向 a 数组的第 0 号元素

在 C 语言中，数组名代表数组中首元素（即序号为 0 的元素）的地址。因此，下面两个语句等价
```
p = &a[0];  //p 的值是 a[0] 的地址
p = a;      //p 的值是数组 a 首元素（即 a[0]）的地址
```

数组名不代表整个数组，只代表数组首元素的地址。上述 p=a; 的作用是“把 a 数组的首元素的地址赋给指针变量 p”，而不是“把数组 a 各元素的值赋给 p”

### 通过指针对数组元素进行操作

1. 如果指针变量 p 已指向数组中的一个元素，则 p+1 指向同一数组中的下一个元素。p-1 指向同一数组中的上一个元素。

注意:执行 p+1 时并不是将 p 的值（地址）简单地加 1，而是加上一个数组元素所占用的字节数

例如，数组元素是 float 型，每个元素占 4 个字节，则 p+1 意味着使 p 的值加 4 个字节，以使它指向下一个元素。p+1 所代表的地址实际上是 p+1*d，d 是一个数组元素所占的字节数。若 p 的值是 2000，则 p+1 的值不是 2001 而是 2004

2. 如果 p 的初值为 &a[0]，则 p+i 和 a+i 就是数组元素 a[i] 的地址，或者说，他们指向 a 数组序号为 i 的元素。

这里注意的是 a 代表数组首元素的地址，a+1 也是地址，它的计算方法同 p+1，即它的实际地址为 a+1*d。例如，p+9 和 a+9 的值是 &a[9]，它指向 a[9]

```
#include<stdio.h>
int main(){
    int a[10];
    int i;

    printf("please enter 10 integer numbers: ");
    for(i=0;i<10;i++)
        scanf("%d",&a[i]);

    for(i=0;i<10;i++)
        printf("%d\t",a[i]);     //数组元素用数组名和下标表示
        printf("%d\t",*(a+i));   //通过数组名和元素序号计算元素地址，再找该元素
    return 0;
}
```
```
// 这种方法最快
// 用指针变量直接指向元素，不必每次都重新计算地址，像 p++ 这样的自加操作是比较快的。这种有规律的改变地址值 p++ 能大大提高执行效率
#include<stdio.h>
int main(){
    int a[10];
    int *p,i;

    printf("please enter 10 integer numbers: ");
    for(i=0;i<10;i++)
        scanf("%d",&a[i]);

    for(p=a;p<(a+10);p++)
        printf("%d\t",*p);  //用指针指向当前的数组元素

    return 0;
}
```

### 用数组名做函数参数
```
int main(){
    void fun(int arr[],int n);
    int array[10];
             .
             .
             .
    fun(array,10);      //用数组名作为函数的参数
    return 0;
}

void fun(int arr[],int n){
        .
        .
        .
}
```
array 是实参数组名，arr 为形参数组名。从前两节我们应该知道，当用数组名作为参数时，如果形参数组中各元素的值发生变化，实参数组元素的值随之变化

#### 分析
1. 先看数组元素为实参时的情况。如果已经定义一个函数，其原型为void swap(int x,int y);，假设函数的作用是将两个形参 (x,y) 的值交换，现有以下的函数调用swap(a[1],a[2]);。用数组元素 a[1] 和 a[2] 作为实参的情况，与用变量作实参时一样，是“值传递”的方式，将 a[1] 和 a[2] 的值单向传递给 x 和 y。当 x 和 y 的值改变时 a[1] 和 a[2] 的值并没有改变

2. 我们再来看数组名作为函数参数的情况，实参数组名代表该数组首元素的地址，而形参是用来接收从实参传递过来的数组首元素地址的。因此，形参应该是一个指针变量。实际上 C 编译系统是将形参数组名作为指针变量来处理的

例如 `fun(int arr[],int n)` ，在程序编译时是将 arr 按指针变量处理的，相当于将函数 fun 的首部写成 `fun(int *arr,int n);`。 上面的两种写法是等价的。在该函数被调用时，系统会在 fun 函数中建一个指针变量 arr，用来存放从主调函数传递过来的实参数组首元素的地址。当 arr 接收了实参数组的首元素地址后，arr 就指向实参数组首元素，也就是指向 array[0]。因此 `*arr` 就是 `array[0]`，`*(arr+1)` 就是 `array[1]`

我们可以这样来理解，在函数调用期间，形参数组从实参数组那里得到起始地址，因此形参数组与实参数组共占同一段内存单元，在调用函数期间，如果改变了形参数组的值，也就是改变了实参数组的值