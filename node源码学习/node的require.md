## 源码中的require(node源码tags: v12.19.0)
原本想看node是如何实现require的，但是跳到实现require的文件里，开始几行就出现了reqiure，简直一脸懵。
但仔细一看，可以发现，比如说`lib/internal/modules/cjs/loader.js`里需要调用`makeRequireFunction`这个方法，而这个方法就在同一个目录下`lib/internal/modules/cjs/helper.js`，但源码里面是这样调用的
```js
const {
  makeRequireFunction,
  normalizeReferrerURL,
  stripBOM,
  loadNativeModule
} = require('internal/modules/cjs/helpers');
```
这不就是引入依赖的写法吗，难道node把所有文件都作为内置依赖了吗

### `lib/internal/bootstrap`
目录下两个文件`loader.js`,`node.js`有详细的注释，翻译todo

`node.js`开头就是一段hello,那肯定从这里看起，但是下面还是出现了require：
```js
const { deprecate } = require('internal/util');
```
所以先跳过，看`loader.js`
```
This file creates the internal module & binding loaders used by built-in modules
这个文件用来创建用于构建modules的内置模块和binding loaders
...

This file is compiled and run by node.cc before bootstrap/node.js was called,
当前文件是在node.js被调用之前进行编译，被node.cc执行

therefore the loaders are bootstraped before we start to actually bootstrap Node.js
所以在我们开始真真的执行node.js前loaders已被载入

//   NativeModule: a minimal module system used to load the JavaScript core
//   modules found in lib/**/*.js and deps/**/*.js. All core modules are
//   compiled into the node binary via node_javascript.cc generated by js2c.py,
//   so they can be loaded faster without the cost of I/O. This class makes the
//   lib/internal/*, deps/internal/* modules and internalBinding() available by
//   default to core modules, and lets the core modules require itself via
//   require('internal/bootstrap/loaders') even when this file is not written in
//   CommonJS style
大致意思就是lib和deps目录下的都预先被载入作为依赖了
```
在当前文件搜索`require`
```js
const loaderExports = {
  internalBinding,
  NativeModule,
  require: nativeModuleRequire
};

const loaderId = 'internal/bootstrap/loaders';
function nativeModuleRequire(id) {
  if (id === loaderId) {
    return loaderExports;
  }
  // 从NativeModule的Map中获取当前Id对应的依赖
  const mod = NativeModule.map.get(id);
  return mod.compileForInternalLoader();
}
```
虽然有些方法不是太明白，但是大致到这里能明白，源码里的reqiure定义为从已载入的依赖中加载执行，与`lib/modules/cjs`里实现的require不是同一个东西